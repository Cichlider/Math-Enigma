<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Enigma | 最终版</title>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://unpkg.com/d3@3/d3.min.js"></script>
    <script src="https://unpkg.com/function-plot@1/dist/function-plot.js"></script>

    <style>
        :root {
            --bg-color: #0a0a0a;       /* 深邃背景 */
            --text-color: #888888;     /* 辅助文字灰 */
            --formula-color: #ffffff;  /* 公式纯白 */
            --line-glow: rgba(255, 255, 255, 0.5); /* 线条光晕 */
            
            /* 数轴系统颜色 */
            --grid-line: rgba(255, 255, 255, 0.08); /* 网格极淡 */
            --axis-line: rgba(255, 255, 255, 0.5);  /* 主轴稍亮，确保可见 */
            --axis-text: #666666;
        }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Helvetica Neue', 'Arial', sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            user-select: none;
        }

        /* 顶部装饰 */
        header {
            position: absolute;
            top: 40px;
            letter-spacing: 8px;
            font-size: 0.6rem;
            color: #444;
            text-transform: uppercase;
        }

        /* 绘图容器 - 核心视觉区域 */
        #plot-wrapper {
            position: relative;
            width: 100%;
            max-width: 680px;
            height: 420px;
            margin-bottom: 20px;
        }

        #plot-container {
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.6s ease;
        }
        #plot-container.visible { opacity: 1; }

        /* --- Function Plot 深度定制 (CSS Hack) --- */
        
        /* 1. 坐标轴数字 */
        .function-plot text { 
            fill: var(--axis-text) !important; 
            font-size: 11px; 
            font-family: monospace;
        }
        
        /* 2. 网格线 (Grid) - 细微背景 */
        .function-plot .grid .tick { 
            stroke: var(--grid-line) !important; 
            stroke-width: 1px;
        }

        /* 3. 主坐标轴 (X/Y Axis) - 清晰可见 */
        .function-plot .domain { 
            stroke: var(--axis-line) !important; 
            stroke-width: 1.5px !important; 
            fill: none;
        }
        
        /* 4. 原点辅助线 */
        .function-plot .origin {
            stroke: var(--axis-line) !important;
            opacity: 0.8;
        }

        /* 5. 函数曲线 - 发光质感 */
        .function-plot path.line {
            stroke: var(--formula-color) !important;
            stroke-width: 2px !important;
            filter: drop-shadow(0 0 8px var(--line-glow));
            opacity: 0.95;
            transition: d 0.3s; /* 细微形变过渡 */
        }

        /* 公式显示区域 */
        #formula-display {
            font-size: 2rem;
            min-height: 80px;
            color: var(--formula-color);
            opacity: 0;
            transform: translateY(15px);
            transition: all 0.5s ease;
            text-shadow: 0 0 30px rgba(255,255,255,0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
            padding: 0 20px;
            text-align: center;
        }
        #formula-display.visible { opacity: 1; transform: translateY(0); }

        /* 极简按钮 */
        .generate-btn {
            background: transparent;
            border: 1px solid #333;
            color: #aaa;
            padding: 12px 40px;
            font-size: 0.8rem;
            letter-spacing: 4px;
            cursor: pointer;
            border-radius: 50px; /* 胶囊圆角 */
            transition: all 0.3s;
            outline: none;
        }
        .generate-btn:hover {
            border-color: #fff;
            color: #fff;
            background: rgba(255,255,255,0.05);
            box-shadow: 0 0 20px rgba(255,255,255,0.1);
        }
        .generate-btn:active { transform: scale(0.98); }
        .generate-btn:disabled { opacity: 0.3; cursor: default; transform: none; box-shadow: none; }

    </style>
</head>
<body>

    <header>Function Synthesis Engine</header>

    <div id="plot-wrapper">
        <div id="plot-container"></div>
    </div>

    <div id="formula-display"></div>
    
    <button id="gen-btn" class="generate-btn" onclick="generate()">GENERATE</button>

    <script>
        // ==========================================
        // 1. 核心数学配置
        // ==========================================
        const atoms = [
            { latex: '2', math: '2' },
            { latex: '3', math: '3' },
            { latex: '\\pi', math: '3.14159' }, 
            { latex: 'e', math: '2.71828' }
        ];

        const vars = [
            { latex: 'x', math: 'x' }, 
            { latex: 'x', math: 'x' } // 增加 x 权重
        ];

        const unaryFuncs = [
            { l: (i) => `\\sin(${i})`, m: (i) => `sin(${i})` },
            { l: (i) => `\\cos(${i})`, m: (i) => `cos(${i})` },
            { l: (i) => `\\ln(|${i}|)`, m: (i) => `log(abs(${i})+0.001)` }, // Log 防爆
            { l: (i) => `\\sqrt{|${i}|}`, m: (i) => `sqrt(abs(${i}))` },     // Sqrt 防爆
            { l: (i) => `e^{${i}}`, m: (i) => `exp(${i})` }                   // Exp 防 x 检测错误
        ];

        const binaryOps = [
            // 强制括号与显式乘号，防止 xpi 或 2x 语法错误
            { l: (a,b) => `\\frac{${a}}{${b}}`, m: (a,b) => `((${a})/(${b}))` },
            { l: (a,b) => `${a} \\cdot ${b}`,   m: (a,b) => `((${a})*(${b}))` }, 
            { l: (a,b) => `${a} - ${b}`,       m: (a,b) => `((${a})-(${b}))` },
            { l: (a,b) => `${a} + ${b}`,       m: (a,b) => `((${a})+(${b}))` }
        ];

        function randInt(max) { return Math.floor(Math.random() * max); }

        // ==========================================
        // 2. 递归生成器 (强制含 x 策略)
        // ==========================================
        function buildTree(depth, forceVar) {
            // 到底层时，如果需要变量，强制返回 x
            if (depth <= 0) {
                return forceVar ? vars[randInt(vars.length)] : (Math.random() < 0.4 ? vars[randInt(vars.length)] : atoms[randInt(atoms.length)]);
            }

            const r = Math.random();
            // 15% 概率提前结束（除非被强迫含变量）
            if (r < 0.15 && !forceVar) {
                return Math.random() < 0.5 ? vars[randInt(vars.length)] : atoms[randInt(atoms.length)];
            } 
            // 50% 一元函数
            else if (r < 0.65) {
                const func = unaryFuncs[randInt(unaryFuncs.length)];
                return { 
                    latex: func.l(buildTree(depth - 1, forceVar).latex), 
                    math: func.m(buildTree(depth - 1, forceVar).math) 
                };
            } 
            // 35% 二元函数
            else {
                const op = binaryOps[randInt(binaryOps.length)];
                let forceLeft = false, forceRight = false;
                // 将“必须含x”的责任随机分派给左子树或右子树
                if (forceVar) Math.random() < 0.5 ? forceLeft = true : forceRight = true;
                
                const left = buildTree(depth - 1, forceLeft);
                const right = buildTree(Math.max(0, depth - 2), forceRight);
                return { 
                    latex: op.l(left.latex, right.latex), 
                    math: op.m(left.math, right.math) 
                };
            }
        }

        // ==========================================
        // 3. 终极验证 (反常数、反简单、反空值)
        // ==========================================
        function validateFormula(mathStr) {
            // 1. 正则预检：必须有独立的变量 x (排除 exp, next)
            if (!/\bx\b/.test(mathStr)) return { valid: false };

            const jsCode = mathStr
                .replace(/sin/g, 'Math.sin').replace(/cos/g, 'Math.cos')
                .replace(/tan/g, 'Math.tan').replace(/log/g, 'Math.log')
                .replace(/exp/g, 'Math.exp').replace(/sqrt/g, 'Math.sqrt')
                .replace(/abs/g, 'Math.abs');

            let points = [-5, -2, -0.5, 0.5, 2, 5, 3.14]; // 采样点
            let pairs = []; // 存储 (x, y) 对

            try {
                const f = new Function('x', `return ${jsCode}`);
                for (let x of points) {
                    const y = f(x);
                    if (isFinite(y) && !isNaN(y)) {
                        pairs.push({x, y});
                    }
                }
            } catch(e) { return { valid: false }; }

            // 2. 有效性检查
            if (pairs.length < 5) return { valid: false };

            const ys = pairs.map(p => p.y);
            const min = Math.min(...ys);
            const max = Math.max(...ys);
            const range = max - min;

            // 3. 反常数检查 (波动太小)
            if (range < 0.01) return { valid: false };

            // 4. 【新增】反 f(x)=x 检查 (太简单)
            // 检查是否所有点都满足 y ≈ x
            const isIdentity = pairs.every(p => Math.abs(p.y - p.x) < 0.01);
            if (isIdentity) return { valid: false };
            
            // 检查是否所有点都满足 y ≈ -x
            const isNegIdentity = pairs.every(p => Math.abs(p.y + p.x) < 0.01);
            if (isNegIdentity) return { valid: false };

            // 5. 自动对焦 (Auto-Scaling)
            const center = (min + max) / 2;
            const viewHeight = Math.max(range * 1.4, 12); // 留出上下边距

            return {
                valid: true,
                yDomain: [center - viewHeight/2, center + viewHeight/2]
            };
        }

        function getQualityFormula() {
            let attempts = 0;
            // 尝试 100 次，确保找到高质量公式
            while (attempts < 100) {
                const depth = Math.floor(Math.random() * 3) + 2; 
                const res = buildTree(depth, true); // true = 必须含 x
                const check = validateFormula(res.math);
                
                if (check.valid) {
                    res.yDomain = check.yDomain;
                    return res;
                }
                attempts++;
            }
            // 保底方案
            return {
                latex: "x \\cdot \\sin(x) - \\cos(x)",
                math: "x * sin(x) - cos(x)",
                yDomain: [-10, 10]
            };
        }

        // ==========================================
        // 4. 渲染流程
        // ==========================================
        let plotInstance = null;

        function generate() {
            const btn = document.getElementById('gen-btn');
            const plotDiv = document.getElementById('plot-container');
            const latexDiv = document.getElementById('formula-display');

            // 锁定交互
            btn.disabled = true;
            plotDiv.classList.remove('visible');
            latexDiv.classList.remove('visible');

            // 延迟以播放淡出动画
            setTimeout(() => {
                const data = getQualityFormula();

                // 渲染公式
                katex.render(`f(x) = ${data.latex}`, latexDiv, { throwOnError: false });

                // 渲染图像
                if (plotInstance) plotDiv.innerHTML = ''; // 清理旧SVG
                
                try {
                    plotInstance = functionPlot({
                        target: '#plot-container',
                        width: document.getElementById('plot-wrapper').offsetWidth,
                        height: document.getElementById('plot-wrapper').offsetHeight,
                        yAxis: { domain: data.yDomain },
                        xAxis: { domain: [-6, 6] },
                        grid: true, // 开启网格
                        data: [{
                            fn: data.math,
                            sampler: 'builtIn',
                            graphType: 'polyline',
                            nSamples: 4000 // 高精度采样，曲线顺滑
                        }],
                        disableZoom: true,
                        disablePan: true
                    });
                    
                    // 淡入
                    plotDiv.classList.add('visible');
                    latexDiv.classList.add('visible');
                } catch(e) {
                    console.error("Plot Failed");
                }

                btn.disabled = false;
            }, 300);
        }

        // 初始化
        window.onload = generate;
        
        // 窗口调整时简单重绘
        window.onresize = () => { 
            if(!document.getElementById('gen-btn').disabled) generate(); 
        };

    </script>
</body>
</html>